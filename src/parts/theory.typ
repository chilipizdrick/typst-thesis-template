#import "../lib.typ": *
#show: fix-indent()

= Алгоритмы построения суффиксного дерева <theory>

== Понятие суффиксного дерева

#figure(
  image("../images/suffix-tree.png", width: 80%), caption: [Схема суффиксного дерева для строки _abrakadabra_.],
)

В компьютерных науках суффиксным деревом принято называть бор#footnote(
  [Префиксное дерево (бор) --- структура данных, представляющая из себя дерево с
    символами на ребрах. При прохождении от корня к произвольному листу указанного
    дерева последовательная запись символов на ребрах образует закодированную
    строку.],
), построенный на суффиксах некоторой строки/последовательности. Такая структура
данных позволяет решать набор задач за линейное время, в отличие от тривиальных
решений указанных задач, которые занимают асимтотически большее время. К таким
задачам можно отнести:
- Поиск количества различных подстрок данной строки
- Поиск наибольшей общей подстроки двух строк
- Нахождение суффиксного массива и массива _lcp_ (longest common prefix) исходной
  строки
Для реализации большинства алгоритмов построения суффиксного дерева необходимо
добавление в конец изначального слова защитного символа, не входящего в "алфавит",
на котором построено указанное слово.

#figure(
  image("../images/abbabac.png", width: 50%), caption: [Схема суффиксного дерева для строки _abbabac\$_, где _\$_ --- защитный символ,
    значения в листьях --- индексы, по которым встречаются закодированные суффиксы.],
)

== "Наивный" алгоритм построения суффиксного дерева

Для построения сжатого суффиксного дерева в учебных целях часто рассматривается
"наивный" алгоритм, который так называется по причине его низкой
производительности. Ход алгоритма заключается в переборе всех суффиксов от
самого длинного (непосредственно самой строки/последовательности) до самого
короткого. При этом если в строящемся дереве уже существует суффикс, совпадающий
с добавляемым суффиксом некоторым префиксом, указанный префикс выносится в
отдельный узел дерева, а его дочерними элементами становятся различающиеся части
указанных суффиксов.

Описанный алгоритм является простейшим из рассматриваемых в работе и имеет
временную сложность в $O(n^2)$ и пространственную сложность в $O(n)$. Еще одним
недостатком описанного алгоритма является тот факт, что это _offline_ алгоритм,
то есть для его работы необходимо заранее знать всю изначальную строку целиком.
Далее рассматриваемые алгоритмы будут значительно быстрее и экономнее в
отношении затрачиваемой памяти.

== Алгоритм МакКрейта

Алгоритм построения суффиксного дерева, предложенный МакКрейтом в 1976 году,
схож с рассматриваемым в предыдущем разделе "наивным" алгоритмом тем, что в нем
рассматриваются суффиксы в порядке уменьшения длин суффиксов. Отличие же
заключается в том, что для быстрого вычисления места, откуда нужно продолжить
построение нового суффикса, алгоритм добавляет суффиксную ссылку#footnote(
  [Пусть $x alpha$ обозначает произвольную строку, где $x$ --- её первый символ, а $alpha$
    --- оставшаяся подстрока (возможно пустая). Если для внутренней вершины $v$ с
    путевой меткой $x alpha$ существует другая вершина $s(v)$ с путевой меткой $alpha$,
    то ссылка из $v$ в $s(v)$ называется суффиксной ссылкой.],
) в каждой вершине. Данная операция позволяет снизить временную сложность с $O(n^2)$ до $O(n)$.

Преимуществом алгоритма МакКрейта в сравнении с предшествующим ему исторически
алгоритмом Вайнера (1973 год) стала значительная экономность в отношении памяти,
затрачиваемой алгоритмом (алгоритм МакКрейта обладает пространственной
сложностью в $O(n)$). Алгоритм Вайнера для своей работы требовал хранения в
каждом узле двух массивов размера алфавита, на котором построено слово, что
делало его крайне затратным в отношении используемой памяти.

Недостатком же рассматриваемого алгоритма является то, что он также как и "наивный"
алгоритм является _offline_ алгоритмом, что ограничивает его применение в
некоторых случаях.

== Алгоритм Укконена

Алгоритм Укконена построения суффиксного дерева (также называемый алгоритмом _ukk_),
аналогично алгоритму МакКрейта, требует линейное количество времени и памяти
(амортизированная оценка), а также является _online_ алгоритмом, в чем и
заключается его главное преимущество. @ukkonen Подобная скорость и экономность
по памяти обусловлена рядом оптимизаций, которые применены к простейшему
алгоритму построения суффиксного дерева, который требует порядка $O(n^3)$ времени
для своей работы.

#figure(
  image("../images/ukkonen.png", width: 80%), caption: [Построение суффиксного дерева за $O(n^3)$ для слова _abca\$_.],
) <ukkonen-pic>

Как можно видеть на рисунке @ukkonen-pic, суть алгоритма с временной сложностью
в $O(n^3)$ --- последовательно добавлять в суффиксное дерево еще не существующий
в нем суффикс и продлевать существующие. Укконен предложил оптимизировать
указанный алгоритм следующими тремя способами:
+ Так как при добавлении символа к листу дерева образуется новый лист, можно по
  умолчанию создавать лист до конца строки, что можно выразить в равенстве
  бесконечности индекса правой границы рассматриваемой подстроки.
+ Прохождение по ребру дерева для большего суффикса означает, что прохождение по
  этому ребру для меньших суффиксов уже произошло, поэтому алгоритм не будет
  повторять это действие для меньших суффиксов.
+ Для увеличения скорости работы алгоритма и уменьшения затрачиваемого
  пространства вводятся суффиксные ссылки. Работа алгоритма сводится к повторению
  фаз, использующих последовательно 3 правила продления суффикса (продление листа,
  создание развилки, ничего не делать) и вводится лемма, гласящая о том, что при
  применении 3-го типа продления в продолжении суффикса, начинающегося в позиции $j$ оно
  же и будет применяться во всех дальнейших продолжениях (от $j+1$ по $i$) до
  конца фазы.

Не смотря на свои преимущества при сравнении с вышеупомянутыми алгоритмами,
алгоритм Укконена имеет следующие недостатки:
+ При подробном рассмотрении работы алгоритма, можно заметить, что настоящая
  временная сложность алгоритма --- $O(n dot |Sigma|)$, где $Sigma$ --- алфавит,
  на котором построено слово. По этой причине алгоритм Укконена принимает
  временную сложность в $approx O(n^2)$ при построении суффиксных деревьев для
  нерегулярных слов (слов с редким повторением символов).
+ Константная оценка времени работы одной итерации алгоритма является
  амортизированной, в худшем случае алгоритм совершает одну свою итерацию с
  временной сложностью в $O(n)$, что опять приводит к общей временной сложности
  работы алгоритма в $O(n^2)$.
+ В силу особенностей работы алгоритма, объем памяти, занимаемый созданным
  деревом, может в несколько раз превышать объем памяти, занимаемый входными
  данными, однако он все еще оценивается в $O(n)$.

== Сравнение алгоритмов

Каждый из рассмотренных алгоритмов имеет оценку по пространственной сложности в $O(n)$.
Рассмотрим алгоритмы с точки зрения их временной сложности (Таблица @table1).
#figure(
  table(
    columns: 3, rows: 4, table.header(
      table.cell(rowspan: 2)[], table.cell(colspan: 2)[Временная сложность], [Амортизированная],
      [Худший случай],
    ), ["Наивный" алгоритм],
    [$O(n^2)$], [$O(n^2)$], [Алгоритм МакКрейта], [$O(n)$],
    [$O(n)$], [Алгоритм Укконена], [$O(n)$], [$O(n^2)$#footnote(
        [Только в случаях с большим изначальным алфавитом и обработке нерегулярных строк.],
      )],
  ), caption: [Сравнение временной сложности рассмотренных алгоритмов построения суффиксного
    дерева.],
) <table1>

